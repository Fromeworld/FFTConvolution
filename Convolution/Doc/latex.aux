\relax 
\ifx\hyper@anchor\@undefined
\global \let \oldcontentsline\contentsline
\gdef \contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global \let \oldnewlabel\newlabel
\gdef \newlabel#1#2{\newlabelxx{#1}#2}
\gdef \newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\let \contentsline\oldcontentsline
\let \newlabel\oldnewlabel}
\else
\global \let \hyper@last\relax 
\fi

\@writefile{toc}{\contentsline {section}{\numberline {1}Introduction}{2}{section.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.1}Convolution product : linear and circular}{2}{subsection.1.1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.1.1}Definition}{2}{subsubsection.1.1.1}}
\newlabel{eq:linear_convolution_full}{{3}{3}{Definition\relax }{equation.1.3}{}}
\newlabel{eq:linear_convolution_same}{{4}{3}{Definition\relax }{equation.1.4}{}}
\newlabel{eq:linear_convolution_valid}{{5}{3}{Definition\relax }{equation.1.5}{}}
\newlabel{eq:circular_convolution}{{7}{3}{Definition\relax }{equation.1.7}{}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.1.2}Computational complexity}{3}{subsubsection.1.1.2}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces  Schematic illustration of the linear convolution for an odd and even filter size}}{4}{figure.1}}
\newlabel{fig:linear_convolution}{{1}{4}{\label {fig:linear_convolution} Schematic illustration of the linear convolution for an odd and even filter size\relax }{figure.1}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces  Schematic illustration of the circular convolution for an odd and even filter size}}{5}{figure.2}}
\newlabel{fig:circular_convolution}{{2}{5}{\label {fig:circular_convolution} Schematic illustration of the circular convolution for an odd and even filter size\relax }{figure.2}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces  Execution time for computing a linear or circular convolution in C++, using nested for loops, of two signals of size $N$ and $M$. The execution time for a circular convolution grows with $N \times M$. For the linear convolution, the sum is restricted on less indices, which leads to an execution time faster than $N \times M$}}{6}{figure.3}}
\newlabel{fig:benchmark_std_convolution.pdf}{{3}{6}{\label {fig:benchmark_std_convolution.pdf} Execution time for computing a linear or circular convolution in C++, using nested for loops, of two signals of size $N$ and $M$. The execution time for a circular convolution grows with $N \times M$. For the linear convolution, the sum is restricted on less indices, which leads to an execution time faster than $N \times M$\relax }{figure.3}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.2}Discrete Fourier Transform}{6}{subsection.1.2}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.2.1}Introduction}{6}{subsubsection.1.2.1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.2.2}Computing a 2D Fourier transform from 1D Fourier transforms}{7}{subsubsection.1.2.2}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.2.3}Computing 2 DFT at once}{8}{subsubsection.1.2.3}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.2.4}Fast Fourier Transform}{9}{subsubsection.1.2.4}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.2.5}Computational complexity}{9}{subsubsection.1.2.5}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces  Execution time for computing a 2D FFT. With a signal of size $NxN$, the performancs of the FFTW is well approximated with a curve in $N^2 \qopname  \relax o{log}(N)$ while the performances of the GSL sometimes reach $(N^2)^{3/2}$.}}{9}{figure.4}}
\newlabel{fig:test_fft.pdf}{{4}{9}{\label {fig:test_fft.pdf} Execution time for computing a 2D FFT. With a signal of size $NxN$, the performancs of the FFTW is well approximated with a curve in $N^2 \log (N)$ while the performances of the GSL sometimes reach $(N^2)^{3/2}$}{figure.4}{}}
\@writefile{toc}{\contentsline {section}{\numberline {2}2D Convolution product using the Discrete Fourier Transform}{11}{section.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Introduction}{11}{subsection.2.1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.1}Convolution theorem : circular convolution and fourier transform}{11}{subsubsection.2.1.1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.2}Circular convolution of signals of different sizes}{12}{subsubsection.2.1.2}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.3}Circular convolution : summary}{13}{subsubsection.2.1.3}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.4}Linear convolutions : particular cases of circular convolution}{13}{subsubsection.2.1.4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}Speeding-up by padding}{14}{subsection.2.2}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.2.1}Linear convolution}{14}{subsubsection.2.2.1}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Execution time for performing a linear convolution with GSL. The times for both the unpadded and padded images are shown. Clearly, padding with zeros in order to get optimal sizes (in the sense of the factor decomposition of GSL) improves the performances.}}{14}{figure.5}}
\newlabel{fig:benchmark_linear_convolution_gsl.pdf}{{5}{14}{\label {fig:benchmark_linear_convolution_gsl.pdf}Execution time for performing a linear convolution with GSL. The times for both the unpadded and padded images are shown. Clearly, padding with zeros in order to get optimal sizes (in the sense of the factor decomposition of GSL) improves the performances}{figure.5}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces Execution time for performing a linear convolution with FFTW. The times for both the unpadded and padded images are shown. Clearly, padding with zeros in order to get optimal sizes (in the sense of the factor decomposition of FFTW) improves the performances.}}{15}{figure.6}}
\newlabel{fig:benchmark_linear_convolution_fftw.pdf}{{6}{15}{\label {fig:benchmark_linear_convolution_fftw.pdf}Execution time for performing a linear convolution with FFTW. The times for both the unpadded and padded images are shown. Clearly, padding with zeros in order to get optimal sizes (in the sense of the factor decomposition of FFTW) improves the performances}{figure.6}{}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.2.2}Circular convolution}{15}{subsubsection.2.2.2}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces Comparison of the execution time for performing a linear convolution using optimal sizes with GSL or FFTW. The FFTW based implementation is slightly better, almost $20\%$ faster for sizes at least $200\times 200$.}}{16}{figure.7}}
\newlabel{fig:benchmark_linear_convolution_compare.pdf}{{7}{16}{\label {fig:benchmark_linear_convolution_compare.pdf}Comparison of the execution time for performing a linear convolution using optimal sizes with GSL or FFTW. The FFTW based implementation is slightly better, almost $20\%$ faster for sizes at least $200\times 200$}{figure.7}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces Execution time for performing a circular convolution with GSL. Two versions are plotted : with or without padding. The two curves of the padded version (solid and dashed) are the boundaries of the execution time, whatever the kernel size.}}{16}{figure.8}}
\newlabel{fig:benchmark_circular_convolution_gsl.pdf}{{8}{16}{\label {fig:benchmark_circular_convolution_gsl.pdf}Execution time for performing a circular convolution with GSL. Two versions are plotted : with or without padding. The two curves of the padded version (solid and dashed) are the boundaries of the execution time, whatever the kernel size}{figure.8}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces Execution time for performing a circular convolution with FFTW. Two versions are plotted : with and without padding with wrapped around values to get optimal sizes. For a circular convolution, padding makes the performances smoother but also worse !}}{17}{figure.9}}
\newlabel{fig:benchmark_circular_convolution_fftw.pdf}{{9}{17}{\label {fig:benchmark_circular_convolution_fftw.pdf}Execution time for performing a circular convolution with FFTW. Two versions are plotted : with and without padding with wrapped around values to get optimal sizes. For a circular convolution, padding makes the performances smoother but also worse !\relax }{figure.9}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {10}{\ignorespaces  Comparison of the execution time for a circular convolution. For the GSL version, we used the minimum of the padded and unpadded times. For the FFTW version, we used the unpadded version. It seems that the FFTW version performs better.}}{17}{figure.10}}
\newlabel{fig:benchmark_circular_convolution_compare.pdf}{{10}{17}{\label {fig:benchmark_circular_convolution_compare.pdf} Comparison of the execution time for a circular convolution. For the GSL version, we used the minimum of the padded and unpadded times. For the FFTW version, we used the unpadded version. It seems that the FFTW version performs better}{figure.10}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3}Comparison between FFT based and standard convolution}{18}{subsection.2.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.4}Putting everything together: 2D image Convolution using the FFT}{18}{subsection.2.4}}
\@writefile{lof}{\contentsline {figure}{\numberline {11}{\ignorespaces  Comparison of the processing time of a linear convolution with different image and filter sizes. Using a FFT based implementation is beneficial only above a certain filter size.}}{18}{figure.11}}
\newlabel{fig:benchmark_linear_everything.pdf}{{11}{18}{\label {fig:benchmark_linear_everything.pdf} Comparison of the processing time of a linear convolution with different image and filter sizes. Using a FFT based implementation is beneficial only above a certain filter size}{figure.11}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {12}{\ignorespaces  Comparison of the processing time of a circular convolution with different image and filter sizes. Using a FFT based implementation is beneficial only above a certain filter size.}}{19}{figure.12}}
\newlabel{fig:benchmark_circular_everything.pdf}{{12}{19}{\label {fig:benchmark_circular_everything.pdf} Comparison of the processing time of a circular convolution with different image and filter sizes. Using a FFT based implementation is beneficial only above a certain filter size}{figure.12}{}}
\@writefile{toc}{\contentsline {section}{\numberline {3}C++ Implementations}{19}{section.3}}
\@writefile{toc}{\contentsline {section}{\numberline {4}References}{20}{section.4}}
